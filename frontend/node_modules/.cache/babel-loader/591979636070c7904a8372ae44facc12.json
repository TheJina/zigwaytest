{"ast":null,"code":"import axios from 'axios';\nimport moment from 'moment';\nimport jwt_decode from 'jwt-decode';\nconst axiosclient = axios.create({\n  baseURL: 'http://localhost:8000'\n});\naxiosclient.interceptors.request.use(async config => {\n  // Decode available tokens\n  let jwta = {};\n  let jwtr = {};\n\n  if (window.localStorage.getItem('jwta') && window.localStorage.getItem('jwtr')) {\n    jwta = jwt_decode(window.localStorage.getItem('jwta'));\n    jwtr = jwt_decode(window.localStorage.getItem('jwtr'));\n  } // Update tokens if the access token is expired and a valid refresh token is available\n\n\n  if (jwta.exp < moment().unix() && jwtr.exp > moment().unix()) {\n    const response = await axios.post(\"http://localhost:8000/api/token/refresh/\", {\n      'refresh': window.localStorage.getItem('jwtr')\n    });\n    window.localStorage.setItem('jwta', response.data.access);\n    window.localStorage.setItem('jwtr', response.data.refresh);\n    jwta = jwt_decode(response.data.access);\n  } // Add access token to request\n\n\n  if (jwta.exp > moment().unix()) {\n    config.headers['Authorization'] = \"Bearer \".concat(window.localStorage.getItem('jwta'));\n  } // Disconnect user if authentication tokens are expired\n  // (Added to avoid unnecessary API calls)\n\n\n  if (jwta.exp < moment().unix() && jwtr.exp < moment().unix()) {\n    window.localStorage.clear();\n    window.location = '/login-page';\n  }\n\n  return config;\n});\naxiosclient.interceptors.response.use(response => {\n  return response;\n}, error => {\n  if (error.response.status === 401) {\n    window.localStorage.clear();\n    window.location = '/';\n  }\n\n  return Promise.reject(error.response);\n});\nexport default axiosclient;","map":{"version":3,"sources":["/home/yakshit-jain/zigwaytest/frontend/src/custom-axios-jwt.js"],"names":["axios","moment","jwt_decode","axiosclient","create","baseURL","interceptors","request","use","config","jwta","jwtr","window","localStorage","getItem","exp","unix","response","post","setItem","data","access","refresh","headers","clear","location","error","status","Promise","reject"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,MAAP,MAAmB,QAAnB;AACA,OAAOC,UAAP,MAAuB,YAAvB;AAEA,MAAMC,WAAW,GAAGH,KAAK,CAACI,MAAN,CAAa;AAC/BC,EAAAA,OAAO,EAAE;AADsB,CAAb,CAApB;AAIAF,WAAW,CAACG,YAAZ,CAAyBC,OAAzB,CAAiCC,GAAjC,CAAqC,MAAOC,MAAP,IAAkB;AACrD;AACA,MAAIC,IAAI,GAAG,EAAX;AACA,MAAIC,IAAI,GAAG,EAAX;;AACA,MAAIC,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4B,MAA5B,KAAuCF,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4B,MAA5B,CAA3C,EAAgF;AAC9EJ,IAAAA,IAAI,GAAGR,UAAU,CAACU,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4B,MAA5B,CAAD,CAAjB;AACAH,IAAAA,IAAI,GAAGT,UAAU,CAACU,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4B,MAA5B,CAAD,CAAjB;AACD,GAPoD,CASrD;;;AACA,MAAIJ,IAAI,CAACK,GAAL,GAAWd,MAAM,GAAGe,IAAT,EAAX,IAA8BL,IAAI,CAACI,GAAL,GAAWd,MAAM,GAAGe,IAAT,EAA7C,EAA8D;AAC5D,UAAMC,QAAQ,GAAG,MAAMjB,KAAK,CAACkB,IAAN,CAAW,0CAAX,EAAuD;AAC5E,iBAAWN,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4B,MAA5B;AADiE,KAAvD,CAAvB;AAGAF,IAAAA,MAAM,CAACC,YAAP,CAAoBM,OAApB,CAA4B,MAA5B,EAAoCF,QAAQ,CAACG,IAAT,CAAcC,MAAlD;AACAT,IAAAA,MAAM,CAACC,YAAP,CAAoBM,OAApB,CAA4B,MAA5B,EAAoCF,QAAQ,CAACG,IAAT,CAAcE,OAAlD;AACAZ,IAAAA,IAAI,GAAGR,UAAU,CAACe,QAAQ,CAACG,IAAT,CAAcC,MAAf,CAAjB;AACD,GAjBoD,CAmBrD;;;AACA,MAAIX,IAAI,CAACK,GAAL,GAAWd,MAAM,GAAGe,IAAT,EAAf,EAAgC;AAC9BP,IAAAA,MAAM,CAACc,OAAP,CAAe,eAAf,qBAA4CX,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4B,MAA5B,CAA5C;AACD,GAtBoD,CAwBrD;AACA;;;AACA,MAAIJ,IAAI,CAACK,GAAL,GAAWd,MAAM,GAAGe,IAAT,EAAX,IAA8BL,IAAI,CAACI,GAAL,GAAWd,MAAM,GAAGe,IAAT,EAA7C,EAA8D;AAC5DJ,IAAAA,MAAM,CAACC,YAAP,CAAoBW,KAApB;AACAZ,IAAAA,MAAM,CAACa,QAAP,GAAkB,aAAlB;AACD;;AAED,SAAOhB,MAAP;AACD,CAhCD;AAkCAN,WAAW,CAACG,YAAZ,CAAyBW,QAAzB,CAAkCT,GAAlC,CACGS,QAAD,IAAc;AACZ,SAAOA,QAAP;AACD,CAHH,EAIGS,KAAD,IAAW;AACT,MAAIA,KAAK,CAACT,QAAN,CAAeU,MAAf,KAA0B,GAA9B,EAAmC;AACjCf,IAAAA,MAAM,CAACC,YAAP,CAAoBW,KAApB;AACAZ,IAAAA,MAAM,CAACa,QAAP,GAAkB,GAAlB;AACD;;AACD,SAAOG,OAAO,CAACC,MAAR,CAAeH,KAAK,CAACT,QAArB,CAAP;AACD,CAVH;AAaA,eAAed,WAAf","sourcesContent":["import axios from 'axios'\nimport moment from 'moment'\nimport jwt_decode from 'jwt-decode'\n\nconst axiosclient = axios.create({\n  baseURL: 'http://localhost:8000'\n})\n\naxiosclient.interceptors.request.use(async (config) => {\n  // Decode available tokens\n  let jwta = {}\n  let jwtr = {}\n  if (window.localStorage.getItem('jwta') && window.localStorage.getItem('jwtr')) {\n    jwta = jwt_decode(window.localStorage.getItem('jwta'))\n    jwtr = jwt_decode(window.localStorage.getItem('jwtr'))\n  }\n\n  // Update tokens if the access token is expired and a valid refresh token is available\n  if (jwta.exp < moment().unix() && jwtr.exp > moment().unix()) {\n    const response = await axios.post(\"http://localhost:8000/api/token/refresh/\", {\n      'refresh': window.localStorage.getItem('jwtr')\n    })\n    window.localStorage.setItem('jwta', response.data.access)\n    window.localStorage.setItem('jwtr', response.data.refresh)\n    jwta = jwt_decode(response.data.access)\n  }\n\n  // Add access token to request\n  if (jwta.exp > moment().unix()) {\n    config.headers['Authorization'] = `Bearer ${window.localStorage.getItem('jwta')}`\n  }\n\n  // Disconnect user if authentication tokens are expired\n  // (Added to avoid unnecessary API calls)\n  if (jwta.exp < moment().unix() && jwtr.exp < moment().unix()) {\n    window.localStorage.clear()\n    window.location = '/login-page'\n  }\n\n  return config\n})\n\naxiosclient.interceptors.response.use(\n  (response) => {\n    return response\n  },\n  (error) => {\n    if (error.response.status === 401) {\n      window.localStorage.clear()\n      window.location = '/'\n    }\n    return Promise.reject(error.response)\n  }\n)\n\nexport default axiosclient"]},"metadata":{},"sourceType":"module"}